// -*- coding: utf-8 -*-

// Created on Mon Dec 30 05:00:34 PM EST 2024
// author: Ryan Hildebrandt, github.com/ryancahildebrandt

package main

import (
	"errors"
	"slices"
	"testing"
)

func TestBuildEdgeList(t *testing.T) {
	dummy_error := errors.New("")
	lexer := NewJSGFLexer()
	table := []struct {
		r   string
		exp EdgeList
		err error
	}{
		{
			"",
			EdgeList{},
			dummy_error,
		},
		{
			"=",
			EdgeList{},
			dummy_error,
		},
		{
			"<>=;",
			EdgeList{},
			dummy_error,
		},
		{
			"public <test> = ;",
			EdgeList{{0, 1, 1.0}, {1, 2, 1.0}},
			nil,
		},
		{
			"public <test> = one two three;",
			EdgeList{{0, 1, 1.0}, {1, 2, 1.0}, {2, 3, 1.0}},
			nil,
		},
		{
			"public <test> = four|five|six;",
			EdgeList{{0, 1, 1.0}, {0, 3, 1.0}, {0, 5, 1.0}, {1, 6, 1.0}, {3, 6, 1.0}, {5, 6, 1.0}, {6, 7, 1.0}},
			nil,
		},
		{
			"public <test> = six[ seven][ eight];",
			EdgeList{{0, 1, 1.0}, {1, 2, 1.0}, {2, 3, 1.0}, {2, 4, 1.0}, {3, 4, 1.0}, {4, 5, 1.0}, {5, 6, 1.0}, {5, 7, 1.0}, {6, 7, 1.0}, {7, 8, 1.0}, {8, 9, 1.0}},
			nil,
		},
		{
			"public <test> = eight( nine)( ten);",
			EdgeList{{0, 1, 1.0}, {1, 2, 1.0}, {2, 3, 1.0}, {3, 4, 1.0}, {4, 5, 1.0}, {5, 6, 1.0}, {6, 7, 1.0}, {7, 8, 1.0}, {8, 9, 1.0}},
			nil,
		},
		{
			"public <test> = 11 [12|13|14];",
			EdgeList{{0, 1, 1.0}, {1, 2, 1.0}, {2, 3, 1.0}, {2, 5, 1.0}, {2, 7, 1.0}, {2, 8, 1.0}, {3, 8, 1.0}, {5, 8, 1.0}, {7, 8, 1.0}, {8, 9, 1.0}, {9, 10, 1.0}},
			nil,
		},
		{
			"public <test> = 11 (12|13|14);",
			EdgeList{{0, 1, 1.0}, {1, 2, 1.0}, {2, 3, 1.0}, {2, 5, 1.0}, {2, 7, 1.0}, {3, 8, 1.0}, {5, 8, 1.0}, {7, 8, 1.0}, {8, 9, 1.0}, {9, 10, 1.0}},
			nil,
		},
		{
			"public <test> = 11 (((12)));",
			EdgeList{{0, 1, 1.0}, {1, 2, 1.0}, {2, 3, 1.0}, {3, 4, 1.0}, {4, 5, 1.0}, {5, 6, 1.0}, {6, 7, 1.0}, {7, 8, 1.0}, {8, 9, 1.0}, {9, 10, 1.0}},
			nil,
		},
		{
			"public <test> = 11 ((12)(13)(14));",
			EdgeList{{0, 1, 1.0}, {1, 2, 1.0}, {2, 3, 1.0}, {3, 4, 1.0}, {4, 5, 1.0}, {5, 6, 1.0}, {6, 7, 1.0}, {7, 8, 1.0}, {8, 9, 1.0}, {9, 10, 1.0}, {10, 11, 1.0}, {11, 12, 1.0}, {12, 13, 1.0}, {13, 14, 1.0}},
			nil,
		},
		{
			"public <test> = 11 ((12)|(13)|(14));",
			EdgeList{{0, 1, 1.0}, {1, 2, 1.0}, {2, 3, 1.0}, {3, 4, 1.0}, {4, 5, 1.0}, {5, 14, 1.0}, {2, 7, 1.0}, {7, 8, 1.0}, {8, 9, 1.0}, {9, 14, 1.0}, {2, 11, 1.0}, {11, 12, 1.0}, {12, 13, 1.0}, {13, 14, 1.0}, {14, 15, 1.0}, {15, 16, 1.0}},
			nil,
		},
		{
			"public <test> = 11 ([[12]]);",
			EdgeList{{0, 1, 1.0}, {1, 2, 1.0}, {2, 3, 1.0}, {3, 4, 1.0}, {4, 5, 1.0}, {5, 6, 1.0}, {6, 7, 1.0}, {7, 8, 1.0}, {8, 9, 1.0}, {3, 7, 1.0}, {4, 6, 1.0}, {9, 10, 1.0}},
			nil,
		},
		{
			"public <test> = 11 ([12][13][14]);",
			EdgeList{{0, 1, 1.0}, {1, 2, 1.0}, {2, 3, 1.0}, {3, 4, 1.0}, {4, 5, 1.0}, {5, 6, 1.0}, {6, 7, 1.0}, {7, 8, 1.0}, {8, 9, 1.0}, {9, 10, 1.0}, {10, 11, 1.0}, {11, 12, 1.0}, {12, 13, 1.0}, {3, 5, 1.0}, {6, 8, 1.0}, {9, 11, 1.0}, {13, 14, 1.0}},
			nil,
		},
		{
			"public <test> = 11 ([12]|[13]|[14]);",
			EdgeList{{0, 1, 1.0}, {1, 2, 1.0}, {2, 3, 1.0}, {3, 4, 1.0}, {4, 5, 1.0}, {5, 14, 1.0}, {14, 15, 1.0}, {2, 7, 1.0}, {7, 8, 1.0}, {8, 9, 1.0}, {9, 14, 1.0}, {2, 11, 1.0}, {11, 12, 1.0}, {12, 13, 1.0}, {13, 14, 1.0}, {3, 5, 1.0}, {7, 9, 1.0}, {11, 13, 1.0}, {15, 16, 1.0}},
			nil,
		},
		{
			"public <test> = 11 [((12))];",
			EdgeList{{0, 1, 1.0}, {1, 2, 1.0}, {2, 3, 1.0}, {3, 4, 1.0}, {4, 5, 1.0}, {5, 6, 1.0}, {6, 7, 1.0}, {7, 8, 1.0}, {8, 9, 1.0}, {2, 8, 1.0}, {9, 10, 1.0}},
			nil,
		},
		{
			"public <test> = 11 [(12)(13)(14)];",
			EdgeList{{0, 1, 1.0}, {1, 2, 1.0}, {2, 3, 1.0}, {3, 4, 1.0}, {4, 5, 1.0}, {5, 6, 1.0}, {6, 7, 1.0}, {7, 8, 1.0}, {8, 9, 1.0}, {9, 10, 1.0}, {10, 11, 1.0}, {11, 12, 1.0}, {12, 13, 1.0}, {2, 12, 1.0}, {13, 14, 1.0}},
			nil,
		},
		{
			"public <test> = 11 [(12)|(13)|(14)];",
			EdgeList{{0, 1, 1.0}, {1, 2, 1.0}, {2, 3, 1.0}, {3, 4, 1.0}, {4, 5, 1.0}, {2, 7, 1.0}, {7, 8, 1.0}, {8, 9, 1.0}, {2, 11, 1.0}, {11, 12, 1.0}, {12, 13, 1.0}, {13, 14, 1.0}, {9, 14, 1.0}, {5, 14, 1.0}, {14, 15, 1.0}, {2, 14, 1.0}, {15, 16, 1.0}},
			nil,
		},
		{
			"public <test> = 11 [[[12]]];",
			EdgeList{{0, 1, 1.0}, {1, 2, 1.0}, {2, 3, 1.0}, {3, 4, 1.0}, {4, 5, 1.0}, {5, 6, 1.0}, {6, 7, 1.0}, {7, 8, 1.0}, {8, 9, 1.0}, {2, 8, 1.0}, {3, 7, 1.0}, {4, 6, 1.0}, {9, 10, 1.0}},
			nil,
		},
		{
			"public <test> = 11 [[12][13][14]];",
			EdgeList{{0, 1, 1.0}, {1, 2, 1.0}, {2, 3, 1.0}, {3, 4, 1.0}, {4, 5, 1.0}, {5, 6, 1.0}, {6, 7, 1.0}, {7, 8, 1.0}, {8, 9, 1.0}, {9, 10, 1.0}, {10, 11, 1.0}, {11, 12, 1.0}, {12, 13, 1.0}, {2, 12, 1.0}, {3, 5, 1.0}, {6, 8, 1.0}, {9, 11, 1.0}, {13, 14, 1.0}},
			nil,
		},
		{
			"public <test> = 11 [[12]|[13]|[14]];",
			EdgeList{{0, 1, 1.0}, {1, 2, 1.0}, {2, 3, 1.0}, {3, 4, 1.0}, {4, 5, 1.0}, {5, 14, 1.0}, {2, 7, 1.0}, {7, 8, 1.0}, {8, 9, 1.0}, {9, 14, 1.0}, {2, 11, 1.0}, {11, 12, 1.0}, {12, 13, 1.0}, {13, 14, 1.0}, {14, 15, 1.0}, {2, 14, 1.0}, {3, 5, 1.0}, {7, 9, 1.0}, {11, 13, 1.0}, {15, 16, 1.0}},
			nil,
		},
		{
			"public <test> = 11 ((12)|(13)[14]) 15;",
			EdgeList{{0, 1, 1.0}, {1, 2, 1.0}, {2, 3, 1.0}, {3, 4, 1.0}, {4, 5, 1.0}, {5, 13, 1.0}, {2, 7, 1.0}, {7, 8, 1.0}, {8, 9, 1.0}, {9, 10, 1.0}, {10, 11, 1.0}, {10, 12, 1.0}, {11, 12, 1.0}, {12, 13, 1.0}, {13, 14, 1.0}, {14, 15, 1.0}, {15, 16, 1.0}},
			nil,
		},
		{
			"public <test> = 11 [(12)|[13]14][15];",
			EdgeList{{0, 1, 1.0}, {1, 2, 1.0}, {2, 3, 1.0}, {3, 4, 1.0}, {4, 5, 1.0}, {5, 11, 1.0}, {2, 7, 1.0}, {7, 8, 1.0}, {8, 9, 1.0}, {9, 10, 1.0}, {7, 9, 1.0}, {10, 11, 1.0}, {2, 11, 1.0}, {11, 12, 1.0}, {12, 13, 1.0}, {13, 14, 1.0}, {14, 15, 1.0}, {12, 14, 1.0}, {15, 16, 1.0}},
			nil,
		},
		{
			"public <test> = [(11)12[13](14)] 15;",
			EdgeList{{0, 1, 1.0}, {1, 2, 1.0}, {2, 3, 1.0}, {3, 4, 1.0}, {4, 5, 1.0}, {5, 6, 1.0}, {6, 7, 1.0}, {7, 8, 1.0}, {8, 9, 1.0}, {9, 10, 1.0}, {10, 11, 1.0}, {11, 12, 1.0}, {12, 13, 1.0}, {13, 14, 1.0}, {1, 12, 1.0}, {6, 8, 1.0}, {14, 15, 1.0}},
			nil,
		},
	}
	for i, test := range table {
		_, v, err := ParseRule(lexer, test.r)
		res := BuildEdgeList(v.Exp.ToTokens(lexer))
		if !slices.Equal(res.Sort(), test.exp.Sort()) {
			t.Errorf("test %v: %v.toArray(lexer)\nGOT %v\nEXP %v", i, test.r, res, test.exp)
		}
		if (test.err != nil && err == nil) || (test.err == nil && err != nil) {
			t.Errorf("test %v: %v.toArray(lexer).err\nGOT %v\nEXP %v", i, test.r, err, test.err)
		}
	}
}

func TestEdgeListSort(t *testing.T) {
	table := []struct {
		e   EdgeList
		exp EdgeList
	}{
		{EdgeList{}, EdgeList{}},
		{EdgeList{{0, 1, 1.0}}, EdgeList{{0, 1, 1.0}}},
		{EdgeList{{0, 1, 1.0}, {1, 2, 1.0}, {2, 3, 1.0}}, EdgeList{{0, 1, 1.0}, {1, 2, 1.0}, {2, 3, 1.0}}},
		{EdgeList{{2, 3, 1.0}, {0, 1, 1.0}, {1, 2, 1.0}}, EdgeList{{0, 1, 1.0}, {1, 2, 1.0}, {2, 3, 1.0}}},
		{EdgeList{{0, 1, 1.0}, {0, 1, 1.0}, {2, 3, 1.0}}, EdgeList{{0, 1, 1.0}, {0, 1, 1.0}, {2, 3, 1.0}}},
	}
	for i, test := range table {
		res := test.e.Sort()
		if !slices.Equal(res, test.exp) {
			t.Errorf("test %v: %v.Sort()\nGOT %v\nEXP %v", i, test.e, res, test.exp)
		}
	}
}

func TestEdgeListUnique(t *testing.T) {
	table := []struct {
		e   EdgeList
		exp EdgeList
	}{
		{EdgeList{}, EdgeList{}},
		{EdgeList{{0, 1, 1.0}}, EdgeList{{0, 1, 1.0}}},
		{EdgeList{{0, 1, 1.0}, {1, 2, 1.0}, {2, 3, 1.0}}, EdgeList{{0, 1, 1.0}, {1, 2, 1.0}, {2, 3, 1.0}}},
		{EdgeList{{2, 3, 1.0}, {0, 1, 1.0}, {0, 1, 1.0}}, EdgeList{{0, 1, 1.0}, {2, 3, 1.0}}},
		{EdgeList{{0, 1, 1.0}, {0, 1, 1.0}, {2, 3, 1.0}, {2, 3, 1.0}}, EdgeList{{0, 1, 1.0}, {2, 3, 1.0}}},
	}
	for i, test := range table {
		res := test.e.Unique()
		if !slices.Equal(res.Sort(), test.exp.Sort()) {
			t.Errorf("test %v: %v.Unique()\nGOT %v\nEXP %v", i, test.e, res, test.exp)
		}
	}
}

func TestEdgeListMax(t *testing.T) {
	table := []struct {
		e   EdgeList
		exp int
	}{
		{EdgeList{}, 0},
		{EdgeList{{0, 0, 1.0}}, 0},
		{EdgeList{{1, 1, 1.0}, {1, 1, 1.0}}, 1},
		{EdgeList{{10, 12, 1.0}, {55, 94, 1.0}, {0, 15, 1.0}, {1, 1, 1.0}}, 94},
		{EdgeList{{-1, 1651, 1.0}, {55, 65, 1.0}, {10, 1, 1.0}, {15, 99, 1.0}, {65, 54, 1.0}, {1000000000, 0, 1.0}, {0, 8, 1.0}, {15, 44, 1.0}}, 1000000000},
	}
	for i, test := range table {
		res := test.e.Max()
		if res != test.exp {
			t.Errorf("test %v: %v.Max()\nGOT %v\nEXP %v", i, test.e, res, test.exp)
		}
	}
}

func TestEdgeListIncrement(t *testing.T) {
	table := []struct {
		e   EdgeList
		n   int
		exp EdgeList
	}{
		{EdgeList{}, 0, EdgeList{}},
		{EdgeList{{0, 0, 1.0}}, 0, EdgeList{{0, 0, 1.0}}},
		{EdgeList{{1, 1, 1.0}, {1, 1, 1.0}}, 1, EdgeList{{2, 2, 1.0}, {2, 2, 1.0}}},
		{EdgeList{{10, 12, 1.0}, {55, 94, 1.0}, {0, 15, 1.0}, {1, 1, 1.0}}, -1, EdgeList{{9, 11, 1.0}, {54, 93, 1.0}, {-1, 14, 1.0}, {0, 0, 1.0}}},
		{EdgeList{{-1, 1651, 1.0}, {55, 65, 1.0}, {10, 1, 1.0}, {15, 99, 1.0}, {65, 54, 1.0}, {1000000000, 0, 1.0}, {0, 8, 1.0}, {15, 44, 1.0}}, 10, EdgeList{{9, 1661, 1.0}, {65, 75, 1.0}, {20, 11, 1.0}, {25, 109, 1.0}, {75, 64, 1.0}, {1000000010, 10, 1.0}, {10, 18, 1.0}, {25, 54, 1.0}}},
	}
	for i, test := range table {
		res := test.e.Increment(test.n)
		if !slices.Equal(res.Sort(), test.exp.Sort()) {
			t.Errorf("test %v: %v,Increment(%v)\nGOT %v\nEXP %v", i, test.e, test.n, res, test.exp)
		}
	}
}
