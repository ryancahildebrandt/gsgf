// -*- coding: utf-8 -*-

// Created on Mon Dec 30 05:00:34 PM EST 2024
// author: Ryan Hildebrandt, github.com/ryancahildebrandt

package main

import (
	"fmt"
	"testing"
)

func TestBuildEdgeList(t *testing.T) {
	lexer := NewJSGFLexer()
	table := []struct {
		rule string
		exp  EdgeList
	}{
		{"public <test> = ;", EdgeList{{0, 1, 1.0}, {1, 2, 1.0}}},
		{"public <test> = one two three;", EdgeList{{0, 1, 1.0}, {1, 2, 1.0}, {2, 3, 1.0}}},
		{"public <test> = four|five|six;", EdgeList{{0, 1, 1.0}, {0, 3, 1.0}, {0, 5, 1.0}, {1, 6, 1.0}, {3, 6, 1.0}, {5, 6, 1.0}, {6, 7, 1.0}}},
		{"public <test> = six[ seven][ eight];", EdgeList{{0, 1, 1.0}, {1, 2, 1.0}, {2, 3, 1.0}, {2, 4, 1.0}, {3, 4, 1.0}, {4, 5, 1.0}, {5, 6, 1.0}, {5, 7, 1.0}, {6, 7, 1.0}, {7, 8, 1.0}, {8, 9, 1.0}}},
		{"public <test> = eight( nine)( ten);", EdgeList{{0, 1, 1.0}, {1, 2, 1.0}, {2, 3, 1.0}, {3, 4, 1.0}, {4, 5, 1.0}, {5, 6, 1.0}, {6, 7, 1.0}, {7, 8, 1.0}, {8, 9, 1.0}}},
		{"public <test> = 11 [12|13|14];", EdgeList{{0, 1, 1.0}, {1, 2, 1.0}, {2, 3, 1.0}, {2, 5, 1.0}, {2, 7, 1.0}, {2, 8, 1.0}, {3, 8, 1.0}, {5, 8, 1.0}, {7, 8, 1.0}, {8, 9, 1.0}, {9, 10, 1.0}}},
		{"public <test> = 11 (12|13|14);", EdgeList{{0, 1, 1.0}, {1, 2, 1.0}, {2, 3, 1.0}, {2, 5, 1.0}, {2, 7, 1.0}, {3, 8, 1.0}, {5, 8, 1.0}, {7, 8, 1.0}, {8, 9, 1.0}, {9, 10, 1.0}}},
		{"public <test> = 11 (((12)));", EdgeList{{0, 1, 1.0}, {1, 2, 1.0}, {2, 3, 1.0}, {3, 4, 1.0}, {4, 5, 1.0}, {5, 6, 1.0}, {6, 7, 1.0}, {7, 8, 1.0}, {8, 9, 1.0}, {9, 10, 1.0}}},
		{"public <test> = 11 ((12)(13)(14));", EdgeList{{0, 1, 1.0}, {1, 2, 1.0}, {2, 3, 1.0}, {3, 4, 1.0}, {4, 5, 1.0}, {5, 6, 1.0}, {6, 7, 1.0}, {7, 8, 1.0}, {8, 9, 1.0}, {9, 10, 1.0}, {10, 11, 1.0}, {11, 12, 1.0}, {12, 13, 1.0}, {13, 14, 1.0}}},
		{"public <test> = 11 ((12)|(13)|(14));", EdgeList{{0, 1, 1.0}, {1, 2, 1.0}, {2, 3, 1.0}, {3, 4, 1.0}, {4, 5, 1.0}, {5, 14, 1.0}, {2, 7, 1.0}, {7, 8, 1.0}, {8, 9, 1.0}, {9, 14, 1.0}, {2, 11, 1.0}, {11, 12, 1.0}, {12, 13, 1.0}, {13, 14, 1.0}, {14, 15, 1.0}, {15, 16, 1.0}}},
		{"public <test> = 11 ([[12]]);", EdgeList{{0, 1, 1.0}, {1, 2, 1.0}, {2, 3, 1.0}, {3, 4, 1.0}, {4, 5, 1.0}, {5, 6, 1.0}, {6, 7, 1.0}, {7, 8, 1.0}, {8, 9, 1.0}, {3, 7, 1.0}, {4, 6, 1.0}, {9, 10, 1.0}}},
		{"public <test> = 11 ([12][13][14]);", EdgeList{{0, 1, 1.0}, {1, 2, 1.0}, {2, 3, 1.0}, {3, 4, 1.0}, {4, 5, 1.0}, {5, 6, 1.0}, {6, 7, 1.0}, {7, 8, 1.0}, {8, 9, 1.0}, {9, 10, 1.0}, {10, 11, 1.0}, {11, 12, 1.0}, {12, 13, 1.0}, {3, 5, 1.0}, {6, 8, 1.0}, {9, 11, 1.0}, {13, 14, 1.0}}},
		{"public <test> = 11 ([12]|[13]|[14]);", EdgeList{{0, 1, 1.0}, {1, 2, 1.0}, {2, 3, 1.0}, {3, 4, 1.0}, {4, 5, 1.0}, {5, 14, 1.0}, {14, 15, 1.0}, {2, 7, 1.0}, {7, 8, 1.0}, {8, 9, 1.0}, {9, 14, 1.0}, {2, 11, 1.0}, {11, 12, 1.0}, {12, 13, 1.0}, {13, 14, 1.0}, {3, 5, 1.0}, {7, 9, 1.0}, {11, 13, 1.0}, {15, 16, 1.0}}},
		{"public <test> = 11 [((12))];", EdgeList{{0, 1, 1.0}, {1, 2, 1.0}, {2, 3, 1.0}, {3, 4, 1.0}, {4, 5, 1.0}, {5, 6, 1.0}, {6, 7, 1.0}, {7, 8, 1.0}, {8, 9, 1.0}, {2, 8, 1.0}, {9, 10, 1.0}}},
		{"public <test> = 11 [(12)(13)(14)];", EdgeList{{0, 1, 1.0}, {1, 2, 1.0}, {2, 3, 1.0}, {3, 4, 1.0}, {4, 5, 1.0}, {5, 6, 1.0}, {6, 7, 1.0}, {7, 8, 1.0}, {8, 9, 1.0}, {9, 10, 1.0}, {10, 11, 1.0}, {11, 12, 1.0}, {12, 13, 1.0}, {2, 12, 1.0}, {13, 14, 1.0}}},
		{"public <test> = 11 [(12)|(13)|(14)];", EdgeList{{0, 1, 1.0}, {1, 2, 1.0}, {2, 3, 1.0}, {3, 4, 1.0}, {4, 5, 1.0}, {2, 7, 1.0}, {7, 8, 1.0}, {8, 9, 1.0}, {2, 11, 1.0}, {11, 12, 1.0}, {12, 13, 1.0}, {13, 14, 1.0}, {9, 14, 1.0}, {5, 14, 1.0}, {14, 15, 1.0}, {2, 14, 1.0}, {15, 16, 1.0}}},
		{"public <test> = 11 [[[12]]];", EdgeList{{0, 1, 1.0}, {1, 2, 1.0}, {2, 3, 1.0}, {3, 4, 1.0}, {4, 5, 1.0}, {5, 6, 1.0}, {6, 7, 1.0}, {7, 8, 1.0}, {8, 9, 1.0}, {2, 8, 1.0}, {3, 7, 1.0}, {4, 6, 1.0}, {9, 10, 1.0}}},
		{"public <test> = 11 [[12][13][14]];", EdgeList{{0, 1, 1.0}, {1, 2, 1.0}, {2, 3, 1.0}, {3, 4, 1.0}, {4, 5, 1.0}, {5, 6, 1.0}, {6, 7, 1.0}, {7, 8, 1.0}, {8, 9, 1.0}, {9, 10, 1.0}, {10, 11, 1.0}, {11, 12, 1.0}, {12, 13, 1.0}, {2, 12, 1.0}, {3, 5, 1.0}, {6, 8, 1.0}, {9, 11, 1.0}, {13, 14, 1.0}}},
		{"public <test> = 11 [[12]|[13]|[14]];", EdgeList{{0, 1, 1.0}, {1, 2, 1.0}, {2, 3, 1.0}, {3, 4, 1.0}, {4, 5, 1.0}, {5, 14, 1.0}, {2, 7, 1.0}, {7, 8, 1.0}, {8, 9, 1.0}, {9, 14, 1.0}, {2, 11, 1.0}, {11, 12, 1.0}, {12, 13, 1.0}, {13, 14, 1.0}, {14, 15, 1.0}, {2, 14, 1.0}, {3, 5, 1.0}, {7, 9, 1.0}, {11, 13, 1.0}, {15, 16, 1.0}}},
		{"public <test> = 11 ((12)|(13)[14]) 15;", EdgeList{{0, 1, 1.0}, {1, 2, 1.0}, {2, 3, 1.0}, {3, 4, 1.0}, {4, 5, 1.0}, {5, 13, 1.0}, {2, 7, 1.0}, {7, 8, 1.0}, {8, 9, 1.0}, {9, 10, 1.0}, {10, 11, 1.0}, {10, 12, 1.0}, {11, 12, 1.0}, {12, 13, 1.0}, {13, 14, 1.0}, {14, 15, 1.0}, {15, 16, 1.0}}},
		{"public <test> = 11 [(12)|[13]14][15];", EdgeList{{0, 1, 1.0}, {1, 2, 1.0}, {2, 3, 1.0}, {3, 4, 1.0}, {4, 5, 1.0}, {5, 11, 1.0}, {2, 7, 1.0}, {7, 8, 1.0}, {8, 9, 1.0}, {9, 10, 1.0}, {7, 9, 1.0}, {10, 11, 1.0}, {2, 11, 1.0}, {11, 12, 1.0}, {12, 13, 1.0}, {13, 14, 1.0}, {14, 15, 1.0}, {12, 14, 1.0}, {15, 16, 1.0}}},
		{"public <test> = [(11)12[13](14)] 15;", EdgeList{{0, 1, 1.0}, {1, 2, 1.0}, {2, 3, 1.0}, {3, 4, 1.0}, {4, 5, 1.0}, {5, 6, 1.0}, {6, 7, 1.0}, {7, 8, 1.0}, {8, 9, 1.0}, {9, 10, 1.0}, {10, 11, 1.0}, {11, 12, 1.0}, {12, 13, 1.0}, {13, 14, 1.0}, {1, 12, 1.0}, {6, 8, 1.0}, {14, 15, 1.0}}},
	}
	for _, test := range table {
		_, v, _ := ParseRule(lexer, test.rule)
		res := BuildEdgeList(v.exp.ToTokens(lexer))
		if fmt.Sprint(res.Sort()) != fmt.Sprint(test.exp.Sort()) {
			t.Errorf("%v.toArray(NewJSGFLexer())\nGOT %v\nEXP %v", test.rule, res, test.exp)
		}
	}
}

func TestEdgeListSort(t *testing.T) {
	table := []struct {
		e   EdgeList
		exp EdgeList
	}{
		{EdgeList{}, EdgeList{}},
		{EdgeList{{0, 1, 1.0}}, EdgeList{{0, 1, 1.0}}},
		{EdgeList{{0, 1, 1.0}, {1, 2, 1.0}, {2, 3, 1.0}}, EdgeList{{0, 1, 1.0}, {1, 2, 1.0}, {2, 3, 1.0}}},
		{EdgeList{{2, 3, 1.0}, {0, 1, 1.0}, {1, 2, 1.0}}, EdgeList{{0, 1, 1.0}, {1, 2, 1.0}, {2, 3, 1.0}}},
		{EdgeList{{0, 1, 1.0}, {0, 1, 1.0}, {2, 3, 1.0}}, EdgeList{{0, 1, 1.0}, {0, 1, 1.0}, {2, 3, 1.0}}},
	}
	for _, test := range table {
		res := test.e.Sort()
		if fmt.Sprint(res) != fmt.Sprint(test.exp) {
			t.Errorf("%v.Sort()\nGOT %v\nEXP %v", test.e, res, test.exp)
		}
	}
}

func TestEdgeListUnique(t *testing.T) {
	table := []struct {
		e   EdgeList
		exp EdgeList
	}{
		{EdgeList{}, EdgeList{}},
		{EdgeList{{0, 1, 1.0}}, EdgeList{{0, 1, 1.0}}},
		{EdgeList{{0, 1, 1.0}, {1, 2, 1.0}, {2, 3, 1.0}}, EdgeList{{0, 1, 1.0}, {1, 2, 1.0}, {2, 3, 1.0}}},
		{EdgeList{{2, 3, 1.0}, {0, 1, 1.0}, {0, 1, 1.0}}, EdgeList{{0, 1, 1.0}, {2, 3, 1.0}}},
		{EdgeList{{0, 1, 1.0}, {0, 1, 1.0}, {2, 3, 1.0}, {2, 3, 1.0}}, EdgeList{{0, 1, 1.0}, {2, 3, 1.0}}},
	}
	for _, test := range table {
		res := test.e.Unique()
		if fmt.Sprint(res.Sort()) != fmt.Sprint(test.exp.Sort()) {
			t.Errorf("%v.Unique()\nGOT %v\nEXP %v", test.e, res, test.exp)
		}
	}
}

func TestEdgeListMax(t *testing.T) {
	table := []struct {
		e   EdgeList
		exp int
	}{
		{EdgeList{}, 0},
		{EdgeList{{0, 0, 1.0}}, 0},
		{EdgeList{{1, 1, 1.0}, {1, 1, 1.0}}, 1},
		{EdgeList{{10, 12, 1.0}, {55, 94, 1.0}, {0, 15, 1.0}, {1, 1, 1.0}}, 94},
		{EdgeList{{-1, 1651, 1.0}, {55, 65, 1.0}, {10, 1, 1.0}, {15, 99, 1.0}, {65, 54, 1.0}, {1000000000, 0, 1.0}, {0, 8, 1.0}, {15, 44, 1.0}}, 1000000000},
	}
	for _, test := range table {
		res := test.e.Max()
		if res != test.exp {
			t.Errorf("%v.Max()\nGOT %v\nEXP %v", test.e, res, test.exp)
		}
	}
}

func TestEdgeListIncrement(t *testing.T) {
	table := []struct {
		e   EdgeList
		n   int
		exp EdgeList
	}{
		{EdgeList{}, 0, EdgeList{}},
		{EdgeList{{0, 0, 1.0}}, 0, EdgeList{{0, 0, 1.0}}},
		{EdgeList{{1, 1, 1.0}, {1, 1, 1.0}}, 1, EdgeList{{2, 2, 1.0}, {2, 2, 1.0}}},
		{EdgeList{{10, 12, 1.0}, {55, 94, 1.0}, {0, 15, 1.0}, {1, 1, 1.0}}, -1, EdgeList{{9, 11, 1.0}, {54, 93, 1.0}, {-1, 14, 1.0}, {0, 0, 1.0}}},
		{EdgeList{{-1, 1651, 1.0}, {55, 65, 1.0}, {10, 1, 1.0}, {15, 99, 1.0}, {65, 54, 1.0}, {1000000000, 0, 1.0}, {0, 8, 1.0}, {15, 44, 1.0}}, 10, EdgeList{{9, 1661, 1.0}, {65, 75, 1.0}, {20, 11, 1.0}, {25, 109, 1.0}, {75, 64, 1.0}, {1000000010, 10, 1.0}, {10, 18, 1.0}, {25, 54, 1.0}}},
	}
	for _, test := range table {
		res := test.e.Increment(test.n)
		if fmt.Sprint(res.Sort()) != fmt.Sprint(test.exp.Sort()) {
			t.Errorf("%v,Increment(%v)\nGOT %v\nEXP %v", test.e, test.n, res, test.exp)
		}
	}
}
